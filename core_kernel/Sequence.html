<div class="ocaml_top"><div class="ocaml_summary"><div class="info">A sequence of elements that can be produced one at a time, on demand, normally with no
sharing.<p>The elements are computed on demand, possibly repeating work if they are demanded
multiple times. A sequence can be built by unfolding from some initial state, which
will in practice often be other containers.</p><p>Most functions constructing a sequence will not immediately compute any elements of
the sequence. These functions will always return in O(1), but traversing the
resulting sequence may be more expensive. The most they will do immediately is
generate a new internal state and a new step function.</p><p>Functions that transform existing sequences sometimes have to reconstruct some suffix
of the input sequence, even if it is unmodified. For example, calling <code class="code">drop 1</code> will
return a sequence with a slightly larger state and whose elements all cost slightly
more to traverse. Because this is sometimes undesirable (for example, applying <code class="code">drop
    1</code> n times will cost O(n) per element traversed in the result), there are also more
eager versions of many functions (whose names are suffixed with <code class="code">_eagerly</code>) that do
more work up front. A function has the <code class="code">_eagerly</code> suffix iff it matches both of these
conditions:</p><p>It might consume an element from an input <code class="code">t</code> before returning.</p><p>It only returns a <code class="code">t</code> (not paired with something else, not wrapped in an <code class="code">option</code>,
etc.). If it returns anything other than a <code class="code">t</code> and it has at least one <code class="code">t</code> input,
it's probably demanding elements from the input <code class="code">t</code> anyway.</p><p>Only <code class="code">*_exn</code> functions can raise exceptions, except if the function underlying the
sequence (the <code class="code">f</code> passed to <code class="code">unfold</code>) raises, in which case the exception will
cascade.</p></div></div>
<div class="ocaml_content"><pre class="odoccode"><span class="TYPEt"><span class="keyword">type</span> <code class="type">+'a </code>t</span></pre>
<pre class="odoccode"><span class="TYPEsequence"><span class="keyword">type</span> <code class="type">'a </code>sequence</span> = <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre>
<div class="ocaml_include" path="http://frenetic-lang.github.io/api//core_kernel/#Container:S1" items="[]" types="[]"><pre class="ocaml_include_handle"><span class="keyword">include</span> <code class="type"><code class="code"><a href="http://frenetic-lang.github.io/api//core_kernel/#Container:S1">Container.S1</a></code> with type t := 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="ocaml_summary"/></div>
<div class="ocaml_include" path="http://frenetic-lang.github.io/api//core_kernel/#Monad:S" items="[&quot;Monad_infix&quot;]" types="[]"><pre class="ocaml_include_handle"><span class="keyword">include</span> <code class="type"><code class="code"><a href="http://frenetic-lang.github.io/api//core_kernel/#Monad:S">Monad.S</a></code> with type t := 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="ocaml_summary"/></div>
<pre class="odoccode"><span class="VALempty"><span class="keyword">val</span> empty</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">empty</code> is a sequence with no elements.</div>
<pre class="odoccode"><span class="VALnext"><span class="keyword">val</span> next</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; ('a * 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a>) option</code></pre><div class="info"><code class="code">next</code> returns the next element of a sequence and the next tail if the sequence is not
finished. It is the most primitive way to walk over a sequence.</div>
<div class="ocaml_module" name="Step"><pre class="odoccode"><span class="keyword">module</span> <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.Step" class="ocaml_internal">Step</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_summary"><div class="info">A <code class="code">Step</code> describes the next step of the sequence construction. <code class="code">Done</code> indicates the
sequence is finished. <code class="code">Skip</code> indicates the sequence continues with another state
without producing the next element yet. <code class="code">Yield</code> outputs an element and introduces a
new state.</div></div><div class="ocaml_content">
<pre class="odoccode"><code><span class="TYPEt"><span class="keyword">type</span> <code class="type">('a, 's) </code>t</span> = </code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Done"><span class="constructor">Done</span></span></code></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Skip"><span class="constructor">Skip</span></span> <span class="keyword">of</span> <code class="type">'s</code></code></td></tr><tr><td align="left" valign="top"><code><span class="keyword">|</span></code></td><td align="left" valign="top"><code><span class="TYPEELTt.Yield"><span class="constructor">Yield</span></span> <span class="keyword">of</span> <code class="type">'a * 's</code></code></td></tr></table></div></div>
<pre class="odoccode"><span class="VALunfold_step"><span class="keyword">val</span> unfold_step</span> : <code class="type">init:'s -&gt; f:('s -&gt; ('a, 's) <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.Step.t" class="ocaml_internal">Step.t</a>) -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">unfold_step ~init ~f</code> constructs a sequence by giving an initial state <code class="code">init</code> and a
function <code class="code">f</code> explaining how to continue the next step from a given state.</div>
<pre class="odoccode"><span class="VALunfold"><span class="keyword">val</span> unfold</span> : <code class="type">init:'s -&gt; f:('s -&gt; ('a * 's) option) -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">unfold ~init f</code> is a simplified version of <code class="code">unfold_step</code> that does not allow
<code class="code">Skip</code>.</div>
<pre class="odoccode"><span class="VALunfold_with"><span class="keyword">val</span> unfold_with</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; init:'s -&gt; f:('s -&gt; 'a -&gt; ('b, 's) <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.Step.t" class="ocaml_internal">Step.t</a>) -&gt; 'b <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">unfold_with t ~init ~f</code> folds a state through the sequence <code class="code">t</code> to create a new
sequence</div>
<pre class="odoccode"><span class="VALnth"><span class="keyword">val</span> nth</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; int -&gt; 'a option</code></pre><div class="info">return the nth element</div>
<pre class="odoccode"><span class="VALnth_exn"><span class="keyword">val</span> nth_exn</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; int -&gt; 'a</code></pre>
<pre class="odoccode"><span class="VALmapi"><span class="keyword">val</span> mapi</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; f:(int -&gt; 'a -&gt; 'b) -&gt; 'b <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre>
<pre class="odoccode"><span class="VALfilteri"><span class="keyword">val</span> filteri</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; f:(int -&gt; 'a -&gt; bool) -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre>
<pre class="odoccode"><span class="VALmerge"><span class="keyword">val</span> merge</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; cmp:('a -&gt; 'a -&gt; int) -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">merge t1 t2 ~cmp</code> produces the interleaved elements of <code class="code">t1</code> and <code class="code">t2</code>, always picking
the smallest of the two available elements from <code class="code">t1</code> and <code class="code">t2</code>, according to <code class="code">cmp</code>.
When the two available elements are equal, the one from <code class="code">t1</code> is preferred.</div>
<pre class="odoccode"><span class="VALhd"><span class="keyword">val</span> hd</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a option</code></pre>
<pre class="odoccode"><span class="VALhd_exn"><span class="keyword">val</span> hd_exn</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a</code></pre>
<pre class="odoccode"><span class="VALtl"><span class="keyword">val</span> tl</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> option</code></pre><div class="info"><code class="code">tl t</code> and <code class="code">tl_eagerly_exn t</code> immediately evaluate the first element of <code class="code">t</code> and return
the unevaluated tail.</div>
<pre class="odoccode"><span class="VALtl_eagerly_exn"><span class="keyword">val</span> tl_eagerly_exn</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre>
<pre class="odoccode"><span class="VALfindi"><span class="keyword">val</span> findi</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; f:(int -&gt; 'a -&gt; bool) -&gt; (int * 'a) option</code></pre>
<pre class="odoccode"><span class="VALfind_exn"><span class="keyword">val</span> find_exn</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; f:('a -&gt; bool) -&gt; 'a</code></pre><div class="info"><code class="code">find_exn t ~f</code> returns the first element of <code class="code">t</code> that satisfies <code class="code">f</code>. It raises if
there is no such element.</div>
<pre class="odoccode"><span class="VALappend"><span class="keyword">val</span> append</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">append t1 t2</code> first produces the elements of <code class="code">t1</code>, then produces the elements of
<code class="code">t2</code>.</div>
<pre class="odoccode"><span class="VALconcat"><span class="keyword">val</span> concat</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">concat tt</code> produces the elements of each inner sequence sequentially.</div>
<pre class="odoccode"><span class="VALconcat_map"><span class="keyword">val</span> concat_map</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; f:('a -&gt; 'b <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a>) -&gt; 'b <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">concat_map t ~f</code> is <code class="code">concat (map t ~f)</code>.</div>
<pre class="odoccode"><span class="VALconcat_mapi"><span class="keyword">val</span> concat_mapi</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; f:(int -&gt; 'a -&gt; 'b <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a>) -&gt; 'b <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">concat_mapi t ~f</code> is like concat_map, but passes the index as an argument.</div>
<pre class="odoccode"><span class="VALzip"><span class="keyword">val</span> zip</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'b <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; ('a * 'b) <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info">Transforms a pair of sequences into a sequence of pairs. The length of the returned
sequence is the length of the shorter input. The remaining elements of the longer
input are discarded.<p>WARNING: Unlike <code class="code">List.zip</code>, this will not error out if the two input sequences are of
different lengths, because <code class="code">zip</code> may have already returned some elements by the time
this becomes apparent.</p></div>
<pre class="odoccode"><span class="VALzip_full"><span class="keyword">val</span> zip_full</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'b <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; [ `Both of 'a * 'b | `Left of 'a | `Right of 'b ] <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">zip_full</code> is like <code class="code">zip</code>, but if one sequence ends before the other, then it keeps
producing elements from the other sequence until it has ended as well.</div>
<pre class="odoccode"><span class="VALiteri"><span class="keyword">val</span> iteri</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; f:(int -&gt; 'a -&gt; unit) -&gt; unit</code></pre><div class="info"><code class="code">iteri</code> is just like <code class="code">iter</code>, but it also passes in the index of each element to
<code class="code">f</code>.</div>
<pre class="odoccode"><span class="VALfoldi"><span class="keyword">val</span> foldi</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; f:(int -&gt; 'b -&gt; 'a -&gt; 'b) -&gt; init:'b -&gt; 'b</code></pre><div class="info"><code class="code">foldi</code> is just like <code class="code">fold</code>, but it also passes in the index of each element to
<code class="code">f</code>.</div>
<pre class="odoccode"><span class="VALreduce_exn"><span class="keyword">val</span> reduce_exn</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; f:('a -&gt; 'a -&gt; 'a) -&gt; 'a</code></pre><div class="info"><code class="code">reduce_exn f [a1; ...; an]</code> is <code class="code">f (... (f (f a1 a2) a3) ...) an</code>. It fails on the
empty sequence.</div>
<pre class="odoccode"><span class="VALreduce"><span class="keyword">val</span> reduce</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; f:('a -&gt; 'a -&gt; 'a) -&gt; 'a option</code></pre>
<pre class="odoccode"><span class="VALfind_consecutive_duplicate"><span class="keyword">val</span> find_consecutive_duplicate</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; equal:('a -&gt; 'a -&gt; bool) -&gt; ('a * 'a) option</code></pre><div class="info"><code class="code">find_consecutive_duplicate t ~equal</code> returns the first pair of consecutive elements
<code class="code">(a1, a2)</code> in <code class="code">t</code> such that <code class="code">equal a1 a2</code>. They are returned in the same order as
they appear in <code class="code">t</code>.</div>
<pre class="odoccode"><span class="VALremove_consecutive_duplicates"><span class="keyword">val</span> remove_consecutive_duplicates</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; equal:('a -&gt; 'a -&gt; bool) -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info">The same sequence with consecutive duplicates removed. The relative order of the
other elements is unaffected.</div>
<pre class="odoccode"><span class="VALrange"><span class="keyword">val</span> range</span> : <code class="type">?stride:int -&gt;
?start:[ `exclusive | `inclusive ] -&gt;
?stop:[ `exclusive | `inclusive ] -&gt; int -&gt; int -&gt; int <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">range ?stride ?start ?stop start_i stop_i</code> is the sequence of integers from <code class="code">start_i</code>
to <code class="code">stop_i</code>, stepping by <code class="code">stride</code>. If <code class="code">stride</code> &lt; 0 then we need <code class="code">start_i</code> &gt; <code class="code">stop_i</code>
for the result to be nonempty (or <code class="code">start_i</code> &gt;= <code class="code">stop_i</code> in the case where both bounds
are inclusive).</div>
<pre class="odoccode"><span class="VALinit"><span class="keyword">val</span> init</span> : <code class="type">int -&gt; f:(int -&gt; 'a) -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">init n ~f</code> is <code class="code">[(f 0); (f 1); ...; (f (n-1))]</code>. It is an error if <code class="code">n &lt; 0</code>.</div>
<pre class="odoccode"><span class="VALfilter_map"><span class="keyword">val</span> filter_map</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; f:('a -&gt; 'b option) -&gt; 'b <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">filter_map t ~f</code> produce mapped elements of <code class="code">t</code> which are not <code class="code">None</code>.</div>
<pre class="odoccode"><span class="VALfilter_mapi"><span class="keyword">val</span> filter_mapi</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; f:(int -&gt; 'a -&gt; 'b option) -&gt; 'b <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">filter_mapi</code> is just like <code class="code">filter_map</code>, but it also passes in the index of each
element to <code class="code">f</code>.</div>
<pre class="odoccode"><span class="VALfilter_opt"><span class="keyword">val</span> filter_opt</span> : <code class="type">'a option <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">filter_opt t</code> produces the elements of <code class="code">t</code> which are not <code class="code">None</code>. <code class="code">filter_opt t</code> =
<code class="code">filter_map t ~f:ident</code></div>
<pre class="odoccode"><span class="VALsub"><span class="keyword">val</span> sub</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; pos:int -&gt; len:int -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">sub t ~pos ~len</code> is the <code class="code">len</code>-element subsequence of <code class="code">t</code>, starting at <code class="code">pos</code>. If the
sequence is shorter than <code class="code">pos + len</code>, it returns <code class="code">t[pos] ... t[l-1]</code>, where <code class="code">l</code> is
the length of the sequence.</div>
<pre class="odoccode"><span class="VALtake"><span class="keyword">val</span> take</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; int -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">take t n</code> produces the first <code class="code">n</code> elements of <code class="code">t</code>.</div>
<pre class="odoccode"><span class="VALdrop"><span class="keyword">val</span> drop</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; int -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">drop t n</code> produces all elements of <code class="code">t</code> except the first <code class="code">n</code> elements. If there are
fewer than <code class="code">n</code> elements in <code class="code">t</code>, there is no error; the resulting sequence simply
produces no elements. Usually you will probably want to use <code class="code">drop_eagerly</code> because it
can be significantly cheaper.</div>
<pre class="odoccode"><span class="VALdrop_eagerly"><span class="keyword">val</span> drop_eagerly</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; int -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">drop_eagerly t n</code> immediately consumes the first <code class="code">n</code> elements of <code class="code">t</code> and returns the
unevaluated tail of <code class="code">t</code>.</div>
<pre class="odoccode"><span class="VALtake_while"><span class="keyword">val</span> take_while</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; f:('a -&gt; bool) -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">take_while t ~f</code> produces the longest prefix of <code class="code">t</code> for which <code class="code">f</code> applied to each
element is <code class="code">true</code>.</div>
<pre class="odoccode"><span class="VALdrop_while"><span class="keyword">val</span> drop_while</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; f:('a -&gt; bool) -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">drop_while t ~f</code> produces the suffix of <code class="code">t</code> beginning with the first element of <code class="code">t</code>
for which <code class="code">f</code> is <code class="code">false</code>. Usually you will probably want to use <code class="code">drop_while_option</code>
because it can be significantly cheaper.</div>
<pre class="odoccode"><span class="VALdrop_while_option"><span class="keyword">val</span> drop_while_option</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; f:('a -&gt; bool) -&gt; ('a * 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a>) option</code></pre><div class="info"><code class="code">drop_while_option t ~f</code> immediately consumes the elements from <code class="code">t</code> until the
predicate <code class="code">f</code> fails and returns the first element that failed along with the
unevaluated tail of <code class="code">t</code>. The first element is returned separately because the
alternatives would mean forcing the consumer to evaluate the first element again (if
the previous state of the sequence is returned) or take on extra cost for each element
(if the element is added to the final state of the sequence using <code class="code">shift_right</code>).</div>
<pre class="odoccode"><span class="VALsplit_n_eagerly"><span class="keyword">val</span> split_n_eagerly</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; int -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> * 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">split_n_eagerly t n</code> immediately consumes the first <code class="code">n</code> elements of <code class="code">t</code> and returns
the consumed prefix, as a new stream, along with the unevaluated tail of <code class="code">t</code>.</div>
<pre class="odoccode"><span class="VALshift_right"><span class="keyword">val</span> shift_right</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">shift_right t a</code> produces <code class="code">a</code> and then produces each element of <code class="code">t</code>.</div>
<pre class="odoccode"><span class="VALshift_right_with_list"><span class="keyword">val</span> shift_right_with_list</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a list -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">shift_right_with_list t l</code> produces the elements of <code class="code">l</code>, then produces the elements
of <code class="code">t</code>. It is better to call <code class="code">shift_right_with_list</code> with a list of size n than
<code class="code">shift_right</code> n times; the former will require O(1) work per element produced and the
later O(n) work per element produced.</div>
<pre class="odoccode"><span class="VALshift_left"><span class="keyword">val</span> shift_left</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; int -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">shift_left t n</code> is a synonym for <code class="code">drop t n</code>.</div>
<div class="ocaml_module" name="Infix"><pre class="odoccode"><span class="keyword">module</span> <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.Infix" class="ocaml_internal">Infix</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_summary"/><div class="ocaml_content">
<pre class="odoccode"><span class="VAL(@)"><span class="keyword">val</span> (@)</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre></div></div>
<pre class="odoccode"><span class="VALcartesian_product"><span class="keyword">val</span> cartesian_product</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'b <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; ('a * 'b) <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info">Returns a sequence with all possible pairs. The stepper function of the second
sequence passed as argument may be applied to the same state multiple times, so be
careful using <code class="code">cartesian_product</code> with expensive or side-effecting functions.</div>
<pre class="odoccode"><span class="VALintersperse"><span class="keyword">val</span> intersperse</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; sep:'a -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">intersperse xs ~sep</code> produces <code class="code">sep</code> between adjacent elements of <code class="code">xs</code>.
e.g. <code class="code">intersperse [1;2;3] ~sep:0 = [1;0;2;0;3]</code></div>
<pre class="odoccode"><span class="VALcycle"><span class="keyword">val</span> cycle</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">cycle t</code> repeats the sequence <code class="code">t</code> forever. The elements of <code class="code">t</code> will be recomputed
for each repetition in the cycle.</div>
<pre class="odoccode"><span class="VALrepeat"><span class="keyword">val</span> repeat</span> : <code class="type">'a -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">repeat a</code> repeats <code class="code">a</code> forever.</div>
<pre class="odoccode"><span class="VALsingleton"><span class="keyword">val</span> singleton</span> : <code class="type">'a -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">singleton a</code> produces <code class="code">a</code> exactly once.</div>
<pre class="odoccode"><span class="VALdelayed_fold"><span class="keyword">val</span> delayed_fold</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt;
init:'s -&gt; f:('s -&gt; 'a -&gt; k:('s -&gt; 'r) -&gt; 'r) -&gt; finish:('s -&gt; 'r) -&gt; 'r</code></pre><div class="info"><code class="code">delayed_fold</code> allows to do an on-demand fold, while maintaining a state. This
function is sufficient to implement <code class="code">fold_m</code> in any monad.<pre class="code"><code>      let fold_m t ~init ~f =
        let open M in
        delayed_fold t ~init
          ~f:(fun s a ~k -&gt; f s a &gt;&gt;= k)
          ~finish:return</code></pre><p>It is possible to exit early by not calling <code class="code">k</code> in <code class="code">f</code>. It is also possible to call
<code class="code">k</code> multiple times. This results in the rest of the sequence being folded over
multiple times, independently.</p></div>
<pre class="odoccode"><span class="VALto_list"><span class="keyword">val</span> to_list</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a list</code></pre>
<pre class="odoccode"><span class="VALto_list_rev"><span class="keyword">val</span> to_list_rev</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a list</code></pre><div class="info"><code class="code">to_list_rev t</code> returns a list of the elements of <code class="code">t</code>, in reverse order. It is faster
than <code class="code">to_list</code>.</div>
<pre class="odoccode"><span class="VALof_list"><span class="keyword">val</span> of_list</span> : <code class="type">'a list -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre>
<pre class="odoccode"><span class="VALmemoize"><span class="keyword">val</span> memoize</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">memoize t</code> produces each element of <code class="code">t</code>, but also memoizes them so that if you
consume the same element multiple times it is only computed once. It's a non-eager
version of <code class="code">force_eagerly</code>.</div>
<pre class="odoccode"><span class="VALforce_eagerly"><span class="keyword">val</span> force_eagerly</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">force_eagerly t</code> precomputes the sequence. It is behaviorally equivalent to <code class="code">of_list
    (to_list t)</code>, but may at some point have a more efficient implementation. It's an
eager version of <code class="code">memoize</code>.</div>
<pre class="odoccode"><span class="VALbounded_length"><span class="keyword">val</span> bounded_length</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; at_most:int -&gt; [ `Greater | `Is of int ]</code></pre><div class="info"><code class="code">bounded_length ~at_most t</code> returns <code class="code">`Is len</code> if <code class="code">len = length t &lt;= at_most</code>, and
otherwise returns <code class="code">`Greater</code>. Walks through only as much of the sequence as
necessary. Always returns <code class="code">`Greater</code> if <code class="code">at_most &lt; 0</code>.</div>
<pre class="odoccode"><span class="VALlength_is_bounded_by"><span class="keyword">val</span> length_is_bounded_by</span> : <code class="type">?min:int -&gt; ?max:int -&gt; 'a <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.t" class="ocaml_internal">t</a> -&gt; bool</code></pre><div class="info"><code class="code">length_is_bounded_by ~min ~max t</code> returns true if <code class="code">min &lt;= length t</code> and <code class="code">length t &lt;=
    max</code> When <code class="code">min</code> or <code class="code">max</code> are not provided, the check for that bound is omitted. Walks
through only as much of the sequence as necessary.</div>
<div class="info"><code class="code">Generator</code> is a monadic interface to generate sequences in a direct style, similar to
Python's generators.<p>Here are some examples:</p><pre class="code"><code>      open Generator

      let rec traverse_list = function
        | [] -&gt; return ()
        | x :: xs -&gt; yield x &gt;&gt;= fun () -&gt; traverse_list xs

      let traverse_option = function
        | None -&gt; return ()
        | Some x -&gt; yield x

      let traverse_array arr =
        let n = Array.length arr in
        let rec loop i =
          if i &gt;= n then return () else yield arr.(i) &gt;&gt;= fun () -&gt; loop (i + 1)
        in
        loop 0

      let rec traverse_bst = function
        | Node.Empty -&gt; return ()
        | Node.Branch (left, value, right) -&gt;
          traverse_bst left  &gt;&gt;= fun () -&gt;
          yield        value &gt;&gt;= fun () -&gt;
          traverse_bst right

      let sequence_of_list   x = Generator.run (traverse_list   x)
      let sequence_of_option x = Generator.run (traverse_option x)
      let sequence_of_array  x = Generator.run (traverse_array  x)
      let sequence_of_bst    x = Generator.run (traverse_bst    x)</code></pre></div>
<div class="ocaml_module" name="Generator"><pre class="odoccode"><span class="keyword">module</span> <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.Generator" class="ocaml_internal">Generator</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_summary"/><div class="ocaml_content">
<div class="ocaml_include" path="http://frenetic-lang.github.io/api//core_kernel/#Monad:S2" items="[&quot;Monad_infix&quot;]" types="[&quot;t&quot;]"><pre class="ocaml_include_handle"><span class="keyword">include</span> <code class="type"><code class="code"><a href="http://frenetic-lang.github.io/api//core_kernel/#Monad:S2">Monad.S2</a></code></code></pre><div class="ocaml_summary"/></div>
<pre class="odoccode"><span class="VALyield"><span class="keyword">val</span> yield</span> : <code class="type">'elt -&gt; (unit, 'elt) <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.Generator.t" class="ocaml_internal">t</a></code></pre>
<pre class="odoccode"><span class="VALrun"><span class="keyword">val</span> run</span> : <code class="type">(unit, 'elt) <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.Generator.t" class="ocaml_internal">t</a> -&gt; 'elt <a href="http://frenetic-lang.github.io/api//core_kernel/#Sequence.sequence" class="ocaml_internal">sequence</a></code></pre></div></div>
</div></div>