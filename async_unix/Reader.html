<div class="ocaml_top"><div class="ocaml_summary"><div class="info"><code class="code">Reader</code> is Async's main API for buffered input from a file descriptor. It is the
analog of <code class="code">Core.Std.In_channel</code>.<p>Each reader has an internal buffer, which is filled via <code class="code">read()</code> system calls when
data is needed to satisfy a <code class="code">Reader.read*</code> call.</p><p>Each of the read functions returns a deferred that will become determined when the
read completes. It is an error to have two simultaneous reads. That is, if one calls
a read function, one should not call another read function until the first one
completes.</p><p>If the file descriptor underlying a reader is closed, the reader will return EOF
(after all the buffered bytes have been read).</p><p>Any <code class="code">Reader.read*</code> call could, rather than determine its result, send an exception to
the monitor in effect when <code class="code">read</code> was called. Such exceptions can be handled in the
usual way by using <code class="code">try_with</code>, e.g.:</p><pre class="code"><code>      try_with (fun () -&gt; Reader.read reader ...)</code></pre></div></div>
<div class="ocaml_content"><div class="ocaml_module" name="Read_result"><pre class="odoccode"><span class="keyword">module</span> <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result" class="ocaml_internal">Read_result</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_summary"/><div class="ocaml_content">
<pre class="odoccode"><span class="TYPEt"><span class="keyword">type</span> <code class="type">'a </code>t</span> = <code class="type">[ `Eof | `Ok of 'a ]</code></pre>
<div class="ocaml_include" path="http://frenetic-lang.github.io/api//core/#Std.Monad:S" items="[&quot;Monad_infix&quot;]" types="[]"><pre class="ocaml_include_handle"><span class="keyword">include</span> <code class="type"><code class="code"><a href="http://frenetic-lang.github.io/api//core/#Std.Monad:S">Core.Std.Monad.S</a></code> with type t := 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">t</a></code></pre><div class="ocaml_summary"/></div>
<pre class="odoccode"><span class="VALt_of_sexp"><span class="keyword">val</span> t_of_sexp</span> : <code class="type">(<a href="http://frenetic-lang.github.io/api//sexplib/#Sexp.t">Sexplib.Sexp.t</a> -&gt; 'a) -&gt; <a href="http://frenetic-lang.github.io/api//sexplib/#Sexp.t">Sexplib.Sexp.t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">t</a></code></pre>
<pre class="odoccode"><span class="VAL__t_of_sexp__"><span class="keyword">val</span> __t_of_sexp__</span> : <code class="type">(<a href="http://frenetic-lang.github.io/api//sexplib/#Sexp.t">Sexplib.Sexp.t</a> -&gt; 'a) -&gt; <a href="http://frenetic-lang.github.io/api//sexplib/#Sexp.t">Sexplib.Sexp.t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">t</a></code></pre>
<pre class="odoccode"><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type">('a -&gt; <a href="http://frenetic-lang.github.io/api//sexplib/#Sexp.t">Sexplib.Sexp.t</a>) -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">t</a> -&gt; <a href="http://frenetic-lang.github.io/api//sexplib/#Sexp.t">Sexplib.Sexp.t</a></code></pre>
<pre class="odoccode"><span class="VALbin_t"><span class="keyword">val</span> bin_t</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core/#Std.Bin_prot.Type_class.t">Core.Std.Bin_prot.Type_class.t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">t</a> <a href="http://frenetic-lang.github.io/api//core/#Std.Bin_prot.Type_class.t">Core.Std.Bin_prot.Type_class.t</a></code></pre>
<pre class="odoccode"><span class="VALbin_read_t"><span class="keyword">val</span> bin_read_t</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core/#Std.Bin_prot.Read.reader">Core.Std.Bin_prot.Read.reader</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">t</a> <a href="http://frenetic-lang.github.io/api//core/#Std.Bin_prot.Read.reader">Core.Std.Bin_prot.Read.reader</a></code></pre>
<pre class="odoccode"><span class="VAL__bin_read_t__"><span class="keyword">val</span> __bin_read_t__</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core/#Std.Bin_prot.Read.reader">Core.Std.Bin_prot.Read.reader</a> -&gt;
(int -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">t</a>) <a href="http://frenetic-lang.github.io/api//core/#Std.Bin_prot.Read.reader">Core.Std.Bin_prot.Read.reader</a></code></pre>
<pre class="odoccode"><span class="VALbin_reader_t"><span class="keyword">val</span> bin_reader_t</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core/#Std.Bin_prot.Type_class.reader">Core.Std.Bin_prot.Type_class.reader</a> -&gt;
'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">t</a> <a href="http://frenetic-lang.github.io/api//core/#Std.Bin_prot.Type_class.reader">Core.Std.Bin_prot.Type_class.reader</a></code></pre>
<pre class="odoccode"><span class="VALbin_size_t"><span class="keyword">val</span> bin_size_t</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core/#Std.Bin_prot.Size.sizer">Core.Std.Bin_prot.Size.sizer</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">t</a> <a href="http://frenetic-lang.github.io/api//core/#Std.Bin_prot.Size.sizer">Core.Std.Bin_prot.Size.sizer</a></code></pre>
<pre class="odoccode"><span class="VALbin_write_t"><span class="keyword">val</span> bin_write_t</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core/#Std.Bin_prot.Write.writer">Core.Std.Bin_prot.Write.writer</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">t</a> <a href="http://frenetic-lang.github.io/api//core/#Std.Bin_prot.Write.writer">Core.Std.Bin_prot.Write.writer</a></code></pre>
<pre class="odoccode"><span class="VALbin_writer_t"><span class="keyword">val</span> bin_writer_t</span> : <code class="type">'a <a href="http://frenetic-lang.github.io/api//core/#Std.Bin_prot.Type_class.writer">Core.Std.Bin_prot.Type_class.writer</a> -&gt;
'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">t</a> <a href="http://frenetic-lang.github.io/api//core/#Std.Bin_prot.Type_class.writer">Core.Std.Bin_prot.Type_class.writer</a></code></pre></div></div>
<div class="ocaml_module" name="Id" path="http://frenetic-lang.github.io/api//core/#Std:Unique_id"><pre class="odoccode"><span class="keyword">module</span> <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Id" class="ocaml_internal">Id</a> : <code class="type"><code class="code"><a href="http://frenetic-lang.github.io/api//core/#Std:Unique_id">Core.Std.Unique_id</a></code></code></pre><div class="ocaml_summary"/></div>
<pre class="odoccode"><span class="TYPEt"><span class="keyword">type</span> t</span></pre>
<div class="ocaml_include" path="http://frenetic-lang.github.io/api//core/#Std.Invariant:S" items="[]" types="[]"><pre class="ocaml_include_handle"><span class="keyword">include</span> <code class="type"><code class="code"><a href="http://frenetic-lang.github.io/api//core/#Std.Invariant:S">Core.Std.Invariant.S</a></code> with type t := <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a></code></pre><div class="ocaml_summary"/></div>
<pre class="odoccode"><span class="VALio_stats"><span class="keyword">val</span> io_stats</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Io_stats.t">Io_stats.t</a></code></pre><div class="info"><code class="code">io_stats</code> Overall IO statistics for all readers</div>
<pre class="odoccode"><span class="VALlast_read_time"><span class="keyword">val</span> last_read_time</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; <a href="http://frenetic-lang.github.io/api//core/#Std.Time.t">Core.Std.Time.t</a></code></pre><div class="info"><code class="code">last_read_time t</code> returns time of the most recent <code class="code">read</code> system call that
returned data.</div>
<pre class="odoccode"><span class="VALstdin"><span class="keyword">val</span> stdin</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> <a href="http://frenetic-lang.github.io/api//core/#Std.Lazy.t">Core.Std.Lazy.t</a></code></pre><div class="info"><code class="code">stdin</code> is a reader for file descriptor 0. It is lazy because we don't want
to create it in all programs that happen to link with Async.</div>
<pre class="odoccode"><span class="VALopen_file"><span class="keyword">val</span> open_file</span> : <code class="type">?close_on_exec:bool -&gt; ?buf_len:int -&gt; string -&gt; <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">open_file file</code> opens <code class="code">file</code> for reading and returns a reader reading from it.</div>
<pre class="odoccode"><span class="VALtransfer"><span class="keyword">val</span> transfer</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; string <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Pipe.Writer.t">Import.Pipe.Writer.t</a> -&gt; unit <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">transfer t pipe_w</code> transfers data from <code class="code">t</code> into <code class="code">pipe_w</code> one chunk at a time
(whatever is read from the underlying file descriptor without post-processing). The
result becomes determined after reaching EOF on <code class="code">t</code> and the final bytes have been
transferred, or if <code class="code">pipe_w</code> is closed.<p>This function will normally not be needed (see <code class="code">pipe</code>).</p></div>
<pre class="odoccode"><span class="VALpipe"><span class="keyword">val</span> pipe</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; string <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Pipe.Reader.t">Import.Pipe.Reader.t</a></code></pre><div class="info"><code class="code">pipe t</code> returns the reader end of a pipe that will continually be filled with chunks
of data from the underlying Reader.t. When the reader reaches EOF or the pipe is
closed, <code class="code">pipe</code> closes the the reader, and then after the reader close is finished,
closes the pipe.</div>
<pre class="odoccode"><span class="VALof_pipe"><span class="keyword">val</span> of_pipe</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//core/#Std.Info.t">Core.Std.Info.t</a> -&gt; string <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Pipe.Reader.t">Import.Pipe.Reader.t</a> -&gt; <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">of_pipe info pipe_r</code> returns a reader <code class="code">t</code> that receives all the data from <code class="code">pipe_r</code>.
If <code class="code">pipe_r</code> is closed, <code class="code">t</code> will see an EOF (but will not be automatically closed). If
<code class="code">t</code> is closed, then <code class="code">pipe_r</code> will stop being drained.<p><code class="code">of_pipe</code> is implemented by shuttling bytes from <code class="code">pipe_r</code> to the write-end of a Unix
pipe, with <code class="code">t</code> being attached to the read end of the Unix pipe.</p></div>
<pre class="odoccode"><span class="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">?buf_len:int -&gt; <a href="http://frenetic-lang.github.io/api//async_unix/#Fd.t">Fd.t</a> -&gt; <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">create ~buf_len fd</code> creates a new reader that is reading from <code class="code">fd</code>.<div class="parameters"><div class="param_info"><code class="code">access_raw_data</code> : default = None if specified this function will
be given access to the raw bits as they are read by the reader. No
guarantee of granularity is made.</div></div></div>
<pre class="odoccode"><span class="VALof_in_channel"><span class="keyword">val</span> of_in_channel</span> : <code class="type">in_channel -&gt; <a href="http://frenetic-lang.github.io/api//async_unix/#Fd.Kind.t">Fd.Kind.t</a> -&gt; <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a></code></pre>
<pre class="odoccode"><span class="VALwith_file"><span class="keyword">val</span> with_file</span> : <code class="type">?buf_len:int -&gt;
?exclusive:bool -&gt;
string -&gt; f:(<a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a>) -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">with_file file f</code> opens <code class="code">files</code>, creates a reader with it, and passes the reader to
<code class="code">f</code>. It closes the reader when the result of <code class="code">f</code> becomes determined, and returns
<code class="code">f</code>'s result.<p>NOTE, you need to be careful that all your IO is done when the deferred you return
becomes determined. If for example, you use <code class="code">with_file</code>, and call <code class="code">lines</code>, make sure
you return a deferred that becomes determined when the EOF is reached on the pipe,
not when you get the pipe (because you get it straight away).</p></div>
<pre class="odoccode"><span class="VALclose"><span class="keyword">val</span> close</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; unit <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">close t</code> prevents further use of <code class="code">t</code> and closes <code class="code">t</code>'s underlying file descriptor.
The result of <code class="code">close</code> becomes determined once the underlying file descriptor has been
closed. It is an error to call other operations on <code class="code">t</code> after <code class="code">close t</code> has been
called, except that calls of <code class="code">close</code> subsequent to the original call to <code class="code">close</code> will
return the same deferred as the original call.<p><code class="code">close_finished t</code> becomes determined after <code class="code">t</code>'s underlying file descriptor has been
closed, i.e. it is the same as the result of <code class="code">close</code>. <code class="code">close_finished</code> differs from
<code class="code">close</code> in that it does not have the side effect of initiating a close.</p><p><code class="code">is_closed t</code> returns <code class="code">true</code> iff <code class="code">close t</code> has been called.</p><p><code class="code">with_close t ~f</code> runs <code class="code">f ()</code>, and closes <code class="code">t</code> after <code class="code">f</code> finishes or raises.</p></div>
<pre class="odoccode"><span class="VALclose_finished"><span class="keyword">val</span> close_finished</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; unit <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre>
<pre class="odoccode"><span class="VALis_closed"><span class="keyword">val</span> is_closed</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; bool</code></pre>
<pre class="odoccode"><span class="VALwith_close"><span class="keyword">val</span> with_close</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; f:(unit -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a>) -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre>
<pre class="odoccode"><span class="VALid"><span class="keyword">val</span> id</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Id.t" class="ocaml_internal">Id.t</a></code></pre><div class="info"><code class="code">id t</code> <b>Returns</b> a name for this reader that is unique across all
instances of the reader module.</div>
<pre class="odoccode"><span class="VALfd"><span class="keyword">val</span> fd</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; <a href="http://frenetic-lang.github.io/api//async_unix/#Fd.t">Fd.t</a></code></pre><div class="info"><code class="code">fd t</code> <b>Returns</b> the Fd.t used to create this reader</div>
<pre class="odoccode"><span class="VALread"><span class="keyword">val</span> read</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; ?pos:int -&gt; ?len:int -&gt; string -&gt; int <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">Read_result.t</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">read t ?pos ?len buf</code> reads up to <code class="code">len</code> bytes into buf, blocking
until some data is available or end-of-input is reached. The resulting
<code class="code">i</code> satisfies <code class="code">0 &lt; i &lt;= len</code>.</div>
<pre class="odoccode"><span class="VALdrain"><span class="keyword">val</span> drain</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; unit <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">drain t</code> reads and ignores all data from <code class="code">t</code> until it hits EOF, and then closes
<code class="code">t</code>.</div>
<pre class="odoccode"><span class="TYPEread_one_chunk_at_a_time_result"><span class="keyword">type</span> <code class="type">'a </code>read_one_chunk_at_a_time_result</span> = <code class="type">[ `Eof | `Eof_with_unconsumed_data of string | `Stopped of 'a ]</code></pre><div class="info"><code class="code">read_one_chunk_at_a_time t ~handle_chunk</code> reads into <code class="code">t</code>'s internal buffer,
and whenever bytes are available, applies <code class="code">handle_chunk</code> to them. It waits to read
again until the deferred returned by <code class="code">handle_chunk</code> becomes determined.
<code class="code">read_one_chunk_at_a_time</code> continues reading until it reaches <code class="code">`Eof</code> or <code class="code">handle_chunk</code>
returns <code class="code">`Stop</code> or <code class="code">`Stop_consumed</code>. In the case of <code class="code">`Stop</code> and <code class="code">`Stop_consumed</code>,
one may read from <code class="code">t</code> after <code class="code">read_one_chunk_at_a_time</code> returns.</div>
<pre class="odoccode"><span class="VALread_one_chunk_at_a_time"><span class="keyword">val</span> read_one_chunk_at_a_time</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt;
handle_chunk:(<a href="http://frenetic-lang.github.io/api//core/#Std.Bigstring.t">Core.Std.Bigstring.t</a> -&gt;
              pos:int -&gt;
              len:int -&gt;
              [ `Consumed of int * [ `Need of int | `Need_unknown ]
              | `Continue
              | `Stop of 'a
              | `Stop_consumed of 'a * int ] <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a>) -&gt;
'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.read_one_chunk_at_a_time_result" class="ocaml_internal">read_one_chunk_at_a_time_result</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre>
<pre class="odoccode"><span class="VALread_substring"><span class="keyword">val</span> read_substring</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; <a href="http://frenetic-lang.github.io/api//core/#Std.Substring.t">Core.Std.Substring.t</a> -&gt; int <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">Read_result.t</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">read_substring t ss</code> reads up to <code class="code">Substring.length ss</code> bytes into <code class="code">ss</code>,
blocking until some data is available or Eof is reched. The resulting <code class="code">i</code>
satisfies <code class="code">0 &lt; i &lt;= Substring.length ss</code>.</div>
<pre class="odoccode"><span class="VALread_bigsubstring"><span class="keyword">val</span> read_bigsubstring</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; <a href="http://frenetic-lang.github.io/api//core/#Std.Bigsubstring.t">Core.Std.Bigsubstring.t</a> -&gt; int <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">Read_result.t</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre>
<pre class="odoccode"><span class="VALread_char"><span class="keyword">val</span> read_char</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; char <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">Read_result.t</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre>
<pre class="odoccode"><span class="VALreally_read"><span class="keyword">val</span> really_read</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt;
?pos:int -&gt; ?len:int -&gt; string -&gt; [ `Eof of int | `Ok ] <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">really_read t buf ?pos ?len</code> reads until it fills <code class="code">len</code> bytes of <code class="code">buf</code>
starting at <code class="code">pos</code> or runs out of input. In the former case it returns `Ok.
In the latter, it returns <code class="code">`Eof n</code> where <code class="code">n</code> is the number of bytes that
were read before end of input, and <code class="code">0 &lt;= n &lt; String.length ss</code>.</div>
<pre class="odoccode"><span class="VALreally_read_substring"><span class="keyword">val</span> really_read_substring</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; <a href="http://frenetic-lang.github.io/api//core/#Std.Substring.t">Core.Std.Substring.t</a> -&gt; [ `Eof of int | `Ok ] <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre>
<pre class="odoccode"><span class="VALreally_read_bigsubstring"><span class="keyword">val</span> really_read_bigsubstring</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; <a href="http://frenetic-lang.github.io/api//core/#Std.Bigsubstring.t">Core.Std.Bigsubstring.t</a> -&gt; [ `Eof of int | `Ok ] <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre>
<pre class="odoccode"><span class="VALread_until"><span class="keyword">val</span> read_until</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt;
[ `Char of char | `Pred of char -&gt; bool ] -&gt;
keep_delim:bool -&gt;
[ `Eof | `Eof_without_delim of string | `Ok of string ] <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">read_until t pred ~keep_delim</code> reads until it hits a delimiter <code class="code">c</code> such that:<ul><li>if <code class="code">pred = `Char c'</code> then <code class="code">c = c'</code></li><li>if <code class="code">pred = `Pred p</code> then <code class="code">p c</code></li></ul><code class="code">`Char c'</code> is equivalent to <code class="code">`Pred (fun c -&gt; c = c')</code> but the underlying
implementation is more efficient, in particular it will not call a function on every
input character.<p><code class="code">read_until</code> returns a freshly-allocated string consisting of all the characters read
and optionally including the delimiter as per <code class="code">keep_delim</code>.</p></div>
<pre class="odoccode"><span class="VALread_until_max"><span class="keyword">val</span> read_until_max</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt;
[ `Char of char | `Pred of char -&gt; bool ] -&gt;
keep_delim:bool -&gt;
max:int -&gt;
[ `Eof
| `Eof_without_delim of string
| `Max_exceeded of string
| `Ok of string ] <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info">just like <code class="code">read_until</code>, except you have the option of specifiying a maximum number of
chars to read.</div>
<pre class="odoccode"><span class="VALread_line"><span class="keyword">val</span> read_line</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; string <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">Read_result.t</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">read_line t</code> reads up to, and including the next newline (\n) character (or \r\n) and
returns a freshly-allocated string containing everything up to but not including the
newline character. If <code class="code">read_line</code> encounters EOF before the newline char then
everything read up to but not including EOF will be returned as a line.</div>
<pre class="odoccode"><span class="VALreally_read_line"><span class="keyword">val</span> really_read_line</span> : <code class="type">wait_time:<a href="http://frenetic-lang.github.io/api//core/#Std.Time.Span.t">Core.Std.Time.Span.t</a> -&gt; <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; string option <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">really_read_line ~wait_time t</code> reads up to, and including the next newline (\n)
character and returns an optional, freshly-allocated string containing everything up
to but not including the newline character. If <code class="code">really_read_line</code> encounters EOF
before the newline char, then a time span of <code class="code">wait_time</code> will be used before the input
operation is retried. If the descriptor is closed, <code class="code">None</code> will be returned.</div>
<pre class="odoccode"><span class="TYPEread"><span class="keyword">type</span> <code class="type">'a </code>read</span> = <code class="type">?parse_pos:<a href="http://frenetic-lang.github.io/api//core/#Std.Sexp.Parse_pos.t">Core.Std.Sexp.Parse_pos.t</a> -&gt; 'a</code></pre>
<pre class="odoccode"><span class="VALread_sexp"><span class="keyword">val</span> read_sexp</span> : <code class="type">(<a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; <a href="http://frenetic-lang.github.io/api//core/#Std.Sexp.t">Core.Std.Sexp.t</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">Read_result.t</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a>) <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.read" class="ocaml_internal">read</a></code></pre><div class="info"><code class="code">read_sexp t</code> reads the next sexp.</div>
<pre class="odoccode"><span class="VALread_sexps"><span class="keyword">val</span> read_sexps</span> : <code class="type">(<a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; <a href="http://frenetic-lang.github.io/api//core/#Std.Sexp.t">Core.Std.Sexp.t</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Pipe.Reader.t">Import.Pipe.Reader.t</a>) <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.read" class="ocaml_internal">read</a></code></pre><div class="info"><code class="code">read_sexps t</code> reads all the sexps and returns them as a pipe. When the reader
reaches EOF or the pipe is closed, <code class="code">read_sexps</code> closes the the reader, and then
after the reader close is finished, closes the pipe.</div>
<pre class="odoccode"><span class="VALread_bin_prot"><span class="keyword">val</span> read_bin_prot</span> : <code class="type">?max_len:int -&gt;
<a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt;
'a <a href="http://frenetic-lang.github.io/api//core/#Std.Bin_prot.Type_class.reader">Core.Std.Bin_prot.Type_class.reader</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">Read_result.t</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">read_bin_prot ?max_len t bp_reader</code> reads the next binary protocol message using
binary protocol reader <code class="code">bp_reader</code>. The format is the &quot;size-prefixed binary
protocol&quot;, in which the length of the data is prefixed as a 64-bit integer to the
data. This is the format that <code class="code">Writer.write_bin_prot</code> writes.<p>For higher performance, consider <code class="code">Unpack_sequence.unpack_bin_prot_from_reader</code>.</p></div>
<pre class="odoccode"><span class="VALread_marshal_raw"><span class="keyword">val</span> read_marshal_raw</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; string <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">Read_result.t</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info">Read and return a buffer containing one marshaled value, but don't unmarshal it. You
can just call Marshal.from_string on the string, and cast it to the desired type
(preferrably the actual type). similar to Marshal.from_channel, but suffers from the
String-length limitation (16MB) on 32bit platforms.</div>
<pre class="odoccode"><span class="VALread_marshal"><span class="keyword">val</span> read_marshal</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">Read_result.t</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info">Like read_marshal_raw, but unmarshal the value after reading it</div>
<pre class="odoccode"><span class="VALrecv"><span class="keyword">val</span> recv</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; string <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">Read_result.t</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">recv t</code> returns a string that was written with Writer.send</div>
<pre class="odoccode"><span class="VALread_all"><span class="keyword">val</span> read_all</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; (<a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.Read_result.t" class="ocaml_internal">Read_result.t</a> <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a>) -&gt; 'a <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Pipe.Reader.t">Import.Pipe.Reader.t</a></code></pre><div class="info"><code class="code">read_all t read_one</code> returns a pipe that receives all values read from <code class="code">t</code> by
repeatedly using <code class="code">read_one t</code>. When the reader reaches EOF, it closes the reader,
and then after the reader close is finished, closes the pipe.</div>
<pre class="odoccode"><span class="VALlseek"><span class="keyword">val</span> lseek</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; int64 -&gt; mode:[&lt; `End | `Set ] -&gt; int64 <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">lseek t offset ~mode</code> clears <code class="code">t</code>'s buffer and calls <code class="code">Unix.lseek</code> on <code class="code">t</code>'s file
descriptor. The <code class="code">`Cur</code> mode is not exposed because seeking relative to the current
position of the file descriptor is not the same as seeking to relative to the current
position of the reader.</div>
<pre class="odoccode"><span class="VALlines"><span class="keyword">val</span> lines</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; string <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Pipe.Reader.t">Import.Pipe.Reader.t</a></code></pre><div class="info"><code class="code">lines t</code> reads all the lines from <code class="code">t</code> and puts them in the pipe, one line per pipe
element. The lines do not contain the trailing newline. When the reader reaches EOF
or the pipe is closed, <code class="code">lines</code> closes the the reader, and then after the reader close
is finished, closes the pipe.</div>
<pre class="odoccode"><span class="VALcontents"><span class="keyword">val</span> contents</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; string <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">contents t</code> returns the string corresponding to the full contents (up to EOF) of the
reader. <code class="code">contents</code> closes <code class="code">t</code> before returning the string.</div>
<pre class="odoccode"><span class="VALfile_contents"><span class="keyword">val</span> file_contents</span> : <code class="type">string -&gt; string <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">file_contents file</code> returns the string with the full contents of the file</div>
<pre class="odoccode"><span class="VALfile_lines"><span class="keyword">val</span> file_lines</span> : <code class="type">string -&gt; string list <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">file_lines file</code> returns a list of the lines in the file. The lines do not contain
the trailing newline.</div>
<pre class="odoccode"><span class="TYPEload"><span class="keyword">type</span> <code class="type">('a, 'b) </code>load</span> = <code class="type">?exclusive:bool -&gt;
?expand_macros:bool -&gt;
string -&gt; (<a href="http://frenetic-lang.github.io/api//core/#Std.Sexp.t">Core.Std.Sexp.t</a> -&gt; 'a) -&gt; 'b <a href="http://frenetic-lang.github.io/api//async_unix/#Import.Deferred.t">Import.Deferred.t</a></code></pre><div class="info"><code class="code">load_sexp file conv</code> loads a sexp from <code class="code">file</code> and converts it to a value using
<code class="code">conv</code>. This function provides an accurate error location if <code class="code">convert</code> raises
<code class="code">Of_sexp_error</code>.<p><code class="code">load_sexps</code> is similar, but converts a sequence of sexps.</p><p>Using <code class="code">~expand_macros:true</code> expands macros as defined in Sexplib.Macro. If
<code class="code">~expand_macros:true</code> then the <code class="code">exclusive</code> flag is ignored.</p></div>
<pre class="odoccode"><span class="VALload_sexp"><span class="keyword">val</span> load_sexp</span> : <code class="type">('a, 'a <a href="http://frenetic-lang.github.io/api//core/#Std.Or_error.t">Core.Std.Or_error.t</a>) <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.load" class="ocaml_internal">load</a></code></pre>
<pre class="odoccode"><span class="VALload_sexp_exn"><span class="keyword">val</span> load_sexp_exn</span> : <code class="type">('a, 'a) <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.load" class="ocaml_internal">load</a></code></pre>
<pre class="odoccode"><span class="VALload_sexps"><span class="keyword">val</span> load_sexps</span> : <code class="type">('a, 'a list <a href="http://frenetic-lang.github.io/api//core/#Std.Or_error.t">Core.Std.Or_error.t</a>) <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.load" class="ocaml_internal">load</a></code></pre>
<pre class="odoccode"><span class="VALload_sexps_exn"><span class="keyword">val</span> load_sexps_exn</span> : <code class="type">('a, 'a list) <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.load" class="ocaml_internal">load</a></code></pre>
<pre class="odoccode"><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="http://frenetic-lang.github.io/api//async_unix/#Reader.t" class="ocaml_internal">t</a> -&gt; <a href="http://frenetic-lang.github.io/api//sexplib/#Sexp.t">Sexplib.Sexp.t</a></code></pre>
<pre class="odoccode"><span class="VALsexp_of_read_one_chunk_at_a_time_result"><span class="keyword">val</span> sexp_of_read_one_chunk_at_a_time_result</span> : <code class="type">('a -&gt; <a href="http://frenetic-lang.github.io/api//sexplib/#Sexp.t">Sexplib.Sexp.t</a>) -&gt;
'a <a href="http://frenetic-lang.github.io/api//async_unix/#Reader.read_one_chunk_at_a_time_result" class="ocaml_internal">read_one_chunk_at_a_time_result</a> -&gt; <a href="http://frenetic-lang.github.io/api//sexplib/#Sexp.t">Sexplib.Sexp.t</a></code></pre>
</div></div>