<div class="ocaml_top"><div class="ocaml_summary"><div class="info">The part of the Execution_context that determines what to do when there is an
unhandled exception.<p>Every Async computation runs within the context of some monitor, which, when the
computation is running, is referred to as the &quot;current&quot; monitor. Monitors are
arranged in a tree -- when a new monitor is created, it is a child of the current
monitor.</p><p>If a computation raises an unhandled exception, the behavior depends on whether the
current monitor is &quot;detached&quot; or &quot;attached&quot;. If the monitor has been &quot;detached&quot;, via
one of the <code class="code">detach*</code> functions, then whomever detached it is responsible for dealing
with the exception. If the monitor is still attached, then the exception bubbles to
monitor's parent. If an exception bubbles to the initial monitor, i.e. the root of
the monitor tree, that prints an unhandled-exception message and calls exit 1.</p><h1 id="1_TITLE">NOTE ABOUT THE TOPLEVEL MONITOR</h1><p>It is important to note that in the toplevel monitor, exceptions will only be caught
in the Async part of a computation. For example, in:</p><pre class="code"><code>      upon (f ()) g</code></pre><p>if <code class="code">f</code> raises, the exception will not go to a monitor; it will go to the next caml
exception handler on the stack. Any exceptions raised by <code class="code">g</code> will be caught by the
scheduler and propagated to the toplevel monitor. Because of this it is advised to
always use <code class="code">Scheduler.schedule</code> or <code class="code">Scheduler.within</code>. For example:</p><pre class="code"><code>      Scheduler.within (fun () -&gt; upon (f ()) g)</code></pre><p>This code will catch an exception in either <code class="code">f</code> or <code class="code">g</code>, and propagate it to the
monitor.</p><p>This is only relevant to the toplevel monitor because if you create another monitor
and you wish to run code within it you have no choice but to use <code class="code">Scheduler.within</code>.
<code class="code">try_with</code> creates its own monitor and uses <code class="code">Scheduler.within</code>, so it does not have
this problem.</p></div></div>
<div class="ocaml_content"><pre class="odoccode"><span class="TYPEt"><span class="keyword">type</span> t</span> = <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Raw_monitor.t">Raw_monitor.t</a></code></pre>
<pre class="odoccode"><span class="TYPEwith_optional_monitor_name"><span class="keyword">type</span> <code class="type">'a </code>with_optional_monitor_name</span> = <code class="type">?here:<a href="http://127.0.0.1:8000/core/#Std.Source_code_position.t">Core.Std.Source_code_position.t</a> -&gt;
?info:<a href="http://127.0.0.1:8000/core/#Std.Info.t">Core.Std.Info.t</a> -&gt; ?name:string -&gt; 'a</code></pre>
<pre class="odoccode"><span class="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">(unit -&gt; <a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a>) <a href="http://127.0.0.1:8000/async_kernel/#Monitor.with_optional_monitor_name" class="ocaml_internal">with_optional_monitor_name</a></code></pre><div class="info"><code class="code">create ()</code> returns a new monitor whose parent is the current monitor.</div>
<pre class="odoccode"><span class="VALname"><span class="keyword">val</span> name</span> : <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a> -&gt; <a href="http://127.0.0.1:8000/core/#Std.Info.t">Core.Std.Info.t</a></code></pre><div class="info"><code class="code">name t</code> returns the name of the monitor, or a unique id if no name was supplied to
<code class="code">create</code>.</div>
<pre class="odoccode"><span class="VALparent"><span class="keyword">val</span> parent</span> : <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a> -&gt; <a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a> option</code></pre>
<pre class="odoccode"><span class="VALdepth"><span class="keyword">val</span> depth</span> : <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a> -&gt; int</code></pre>
<pre class="odoccode"><span class="VALcurrent"><span class="keyword">val</span> current</span> : <code class="type">unit -&gt; <a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a></code></pre><div class="info"><code class="code">current ()</code> returns the current monitor</div>
<pre class="odoccode"><span class="VALdetach"><span class="keyword">val</span> detach</span> : <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a> -&gt; unit</code></pre><div class="info"><code class="code">detach t</code> detaches <code class="code">t</code> so that errors raised to <code class="code">t</code> are not passed to <code class="code">t</code>'s parent
monitor. If those errors aren't handled in some other way, then they will effectively
be ignored. One should usually use <code class="code">detach_and_iter_errors</code> so that errors are not
ignored.</div>
<pre class="odoccode"><span class="VALdetach_and_iter_errors"><span class="keyword">val</span> detach_and_iter_errors</span> : <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a> -&gt; f:(exn -&gt; unit) -&gt; unit</code></pre><div class="info"><code class="code">detach_and_iter_errors t ~f</code> detaches <code class="code">t</code> and passes to <code class="code">f</code> all subsequent errors
that reach <code class="code">t</code>, stopping iteration if <code class="code">f</code> raises an exception. An exception raised by
<code class="code">f</code> is sent to the monitor in effect when <code class="code">detach_and_iter_errors</code> was called.</div>
<pre class="odoccode"><span class="VALdetach_and_get_next_error"><span class="keyword">val</span> detach_and_get_next_error</span> : <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a> -&gt; exn <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a></code></pre><div class="info"><code class="code">detach_and_get_next_error t</code> detaches <code class="code">t</code> and returns a deferred that becomes
determined with the next error that reaches <code class="code">t</code> (possibly never).</div>
<pre class="odoccode"><span class="VALdetach_and_get_error_stream"><span class="keyword">val</span> detach_and_get_error_stream</span> : <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a> -&gt; exn <a href="http://127.0.0.1:8000/async_kernel/#Tail.Stream.t">Tail.Stream.t</a></code></pre><div class="info"><code class="code">detach_and_get_error_stream t</code> detaches <code class="code">t</code> and returns a stream of all subsequent
errors that reach <code class="code">t</code>.<p><code class="code">Stream.iter (detach_and_get_error_stream t) ~f</code> is equivalent to
<code class="code">detach_and_iter_errors t ~f</code>.</p></div>
<pre class="odoccode"><span class="VALget_next_error"><span class="keyword">val</span> get_next_error</span> : <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a> -&gt; exn <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a></code></pre><div class="info"><code class="code">get_next_error t</code> returns a deferred that becomes determined the next time <code class="code">t</code> gets
an error, if ever. Calling <code class="code">get_next_error t</code> does not detach <code class="code">t</code>, and if no other
call has detached <code class="code">t</code>, then errors will still bubble up the monitor tree.</div>
<pre class="odoccode"><span class="VALextract_exn"><span class="keyword">val</span> extract_exn</span> : <code class="type">exn -&gt; exn</code></pre><div class="info"><code class="code">extract_exn exn</code> extracts the exn from an error exn that comes from a monitor. If it
is not supplied such an error exn, it returns the exn itself.</div>
<pre class="odoccode"><span class="VALhas_seen_error"><span class="keyword">val</span> has_seen_error</span> : <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a> -&gt; bool</code></pre><div class="info"><code class="code">has_seen_error t</code> returns true iff the monitor has ever seen an error.</div>
<pre class="odoccode"><span class="VALsend_exn"><span class="keyword">val</span> send_exn</span> : <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a> -&gt; ?backtrace:[ `Get | `This of string ] -&gt; exn -&gt; unit</code></pre><div class="info"><code class="code">send_exn t exn ?backtrace</code> sends the exception <code class="code">exn</code> as an error to be handled by
monitor <code class="code">t</code>. By default, the error will not contain a backtrace. However, the caller
can supply one using <code class="code">`This</code>, or use <code class="code">`Get</code> to request that <code class="code">send_exn</code> obtain one
using <code class="code">Exn.backtrace ()</code>.</div>
<pre class="odoccode"><span class="VALtry_with"><span class="keyword">val</span> try_with</span> : <code class="type">(?extract_exn:bool -&gt;
 ?run:[ `Now | `Schedule ] -&gt;
 ?rest:[ `Ignore | `Raise ] -&gt;
 (unit -&gt; 'a <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a>) -&gt; ('a, exn) <a href="http://127.0.0.1:8000/core/#Std.Result.t">Core.Std.Result.t</a> <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a>)
<a href="http://127.0.0.1:8000/async_kernel/#Monitor.with_optional_monitor_name" class="ocaml_internal">with_optional_monitor_name</a></code></pre><div class="info"><code class="code">try_with f</code> runs <code class="code">f ()</code> in a monitor and returns the result as <code class="code">Ok x</code> if <code class="code">f</code> finishes
normally, or returns <code class="code">Error e</code> if there is some error. It either runs <code class="code">f</code> now, if
<code class="code">run = `Now</code>, or schedules a job to run <code class="code">f</code>, if <code class="code">run = `Schedule</code>. Once a result is
returned, the rest of the errors raised by <code class="code">f</code> are ignored or re-raised, as per
<code class="code">rest</code>. <code class="code">try_with</code> never raises synchronously, and may only raise asynchronously with
<code class="code">rest = `Raise</code>.<p>The <code class="code">name</code> argument is used to give a name to the monitor the computation will be
running in. This name will appear when printing errors.</p><p><code class="code">try_with</code> runs <code class="code">f ()</code> in a new monitor <code class="code">t</code> that has no parent. This works because
<code class="code">try_with</code> calls <code class="code">detach_and_get_error_stream t</code> and explicitly handles all errors
sent to <code class="code">t</code>. No errors would ever implicitly propagate to <code class="code">t</code>'s parent, although
<code class="code">try_with</code> will explicitly send them to <code class="code">t</code>'s parent with <code class="code">rest = `Raise</code>.</p><p>If <code class="code">extract_exn = true</code>, then in an <code class="code">Error exn</code> result, the <code class="code">exn</code> will be the actual
exception raised by the computation. If <code class="code">extract_exn = false</code>, then the <code class="code">exn</code> will
include additional information, like the monitor and backtrace. One typically wants
<code class="code">extract_exn = false</code> due to the additional information. However, sometimes one wants
the concision of <code class="code">extract_exn = true</code>.</p></div>
<pre class="odoccode"><span class="VALtry_with_rest_handling"><span class="keyword">val</span> try_with_rest_handling</span> : <code class="type">[ `Default of [ `Ignore | `Raise ] | `Force of [ `Ignore | `Raise ] ] ref</code></pre><div class="info"><code class="code">try_with_rest_handling</code> determines how <code class="code">try_with f ~rest</code> determines the <code class="code">rest</code> value
it actually uses. If <code class="code">!try_with_rest_handling = `Default d</code>, then <code class="code">d</code> is the default
value for <code class="code">rest</code>, but can be overriden by supplying <code class="code">rest</code> to <code class="code">try_with</code>. If
<code class="code">!try_with_rest_handling = Force f</code>, then the <code class="code">rest</code> supplied to <code class="code">try_with</code> is not
used, and <code class="code">f</code> is.<p>Initially, <code class="code">!try_with_rest_handling = `Default `Ignore</code>.</p></div>
<pre class="odoccode"><span class="VALtry_with_ignored_exn_handling"><span class="keyword">val</span> try_with_ignored_exn_handling</span> : <code class="type">[ `Eprintf | `Ignore | `Run of exn -&gt; unit ] ref</code></pre><div class="info"><code class="code">try_with_ignored_exn_handling</code> describes what should happen when <code class="code">try_with</code>'s <code class="code">rest</code>
value is <code class="code">`Ignore</code>, as determined by <code class="code">!try_with_rest_handling</code> and the <code class="code">~rest</code>
supplied to <code class="code">try_with</code>.<p>Initially, <code class="code">!try_with_ignored_exn_handling = `Ignore</code>.</p></div>
<pre class="odoccode"><span class="VALhandle_errors"><span class="keyword">val</span> handle_errors</span> : <code class="type">((unit -&gt; 'a <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a>) -&gt; (exn -&gt; unit) -&gt; 'a <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a>)
<a href="http://127.0.0.1:8000/async_kernel/#Monitor.with_optional_monitor_name" class="ocaml_internal">with_optional_monitor_name</a></code></pre><div class="info"><code class="code">handle_errors ?name f handler</code> runs <code class="code">f ()</code> inside a new monitor with the optionally
supplied name, and calls <code class="code">handler error</code> on every error raised to that monitor. Any
error raised by <code class="code">handler</code> goes to the monitor in effect when <code class="code">handle_errors</code> was
called.<p>Errors that are raised after <code class="code">f ()</code> becomes determined will still be sent to
<code class="code">handler</code>; i.e. the new monitor lives as long as jobs created by <code class="code">f</code> live.</p></div>
<pre class="odoccode"><span class="VALcatch_stream"><span class="keyword">val</span> catch_stream</span> : <code class="type">((unit -&gt; unit) -&gt; exn <a href="http://127.0.0.1:8000/async_kernel/#Tail.Stream.t">Tail.Stream.t</a>) <a href="http://127.0.0.1:8000/async_kernel/#Monitor.with_optional_monitor_name" class="ocaml_internal">with_optional_monitor_name</a></code></pre><div class="info"><code class="code">catch_stream ?name f</code> runs <code class="code">f ()</code> inside a new monitor <code class="code">m</code> and returns the stream of
errors raised to <code class="code">m</code>.</div>
<pre class="odoccode"><span class="VALcatch"><span class="keyword">val</span> catch</span> : <code class="type">((unit -&gt; unit) -&gt; exn <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a>) <a href="http://127.0.0.1:8000/async_kernel/#Monitor.with_optional_monitor_name" class="ocaml_internal">with_optional_monitor_name</a></code></pre><div class="info"><code class="code">catch ?name f</code> runs <code class="code">f ()</code> inside a new monitor <code class="code">m</code> and returns the first error
raised to <code class="code">m</code>.</div>
<pre class="odoccode"><span class="VALprotect"><span class="keyword">val</span> protect</span> : <code class="type">((unit -&gt; 'a <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a>) -&gt;
 finally:(unit -&gt; unit <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a>) -&gt; 'a <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a>)
<a href="http://127.0.0.1:8000/async_kernel/#Monitor.with_optional_monitor_name" class="ocaml_internal">with_optional_monitor_name</a></code></pre><div class="info"><code class="code">protect f ~finally</code> runs <code class="code">f ()</code> and then <code class="code">finally</code> regardless of the success or
failure of <code class="code">f</code>. It re-raises any exception thrown by <code class="code">f</code> or returns whatever <code class="code">f</code>
returned.<p>The <code class="code">name</code> argument is used to give a name to the monitor the computation will be
running in. This name will appear when printing the errors.</p></div>
<pre class="odoccode"><span class="VALmain"><span class="keyword">val</span> main</span> : <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a></code></pre>
<pre class="odoccode"><span class="VALkill"><span class="keyword">val</span> kill</span> : <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a> -&gt; unit</code></pre><div class="info"><code class="code">kill t</code> causes <code class="code">t</code> and all of <code class="code">t</code>'s descendants to never start another job. The job
that calls <code class="code">kill</code> will complete, even if it is a descendant of <code class="code">t</code>.<p><code class="code">kill</code> can break user expectations. For example, users expect in <code class="code">protect f ~finally</code>
that <code class="code">finally</code> will eventually run. However, if the monitor in which <code class="code">finally</code> would
run is killed, then <code class="code">finally</code> will never run.</p></div>
<pre class="odoccode"><span class="VALis_alive"><span class="keyword">val</span> is_alive</span> : <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a> -&gt; bool</code></pre><div class="info"><code class="code">is_alive t</code> returns <code class="code">true</code> iff none of <code class="code">t</code> or its ancestors have been killed.</div>
<div class="ocaml_module" name="Exported_for_scheduler"><pre class="odoccode"><span class="keyword">module</span> <a href="http://127.0.0.1:8000/async_kernel/#Monitor.Exported_for_scheduler" class="ocaml_internal">Exported_for_scheduler</a> : <code class="type"><code class="code">sig</code> .. <code class="code">end</code></code></pre><div class="ocaml_summary"/><div class="ocaml_content">
<pre class="odoccode"><span class="TYPEwith_options"><span class="keyword">type</span> <code class="type">'a </code>with_options</span> = <code class="type">?monitor:<a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a> -&gt; ?priority:<a href="http://127.0.0.1:8000/async_kernel/#Priority.t">Priority.t</a> -&gt; 'a</code></pre>
<pre class="odoccode"><span class="VALwithin'"><span class="keyword">val</span> within'</span> : <code class="type">((unit -&gt; 'a <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a>) -&gt; 'a <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a>) <a href="http://127.0.0.1:8000/async_kernel/#Monitor.Exported_for_scheduler.with_options" class="ocaml_internal">with_options</a></code></pre>
<pre class="odoccode"><span class="VALwithin"><span class="keyword">val</span> within</span> : <code class="type">((unit -&gt; unit) -&gt; unit) <a href="http://127.0.0.1:8000/async_kernel/#Monitor.Exported_for_scheduler.with_options" class="ocaml_internal">with_options</a></code></pre>
<pre class="odoccode"><span class="VALwithin_v"><span class="keyword">val</span> within_v</span> : <code class="type">((unit -&gt; 'a) -&gt; 'a option) <a href="http://127.0.0.1:8000/async_kernel/#Monitor.Exported_for_scheduler.with_options" class="ocaml_internal">with_options</a></code></pre>
<pre class="odoccode"><span class="VALschedule'"><span class="keyword">val</span> schedule'</span> : <code class="type">((unit -&gt; 'a <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a>) -&gt; 'a <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a>) <a href="http://127.0.0.1:8000/async_kernel/#Monitor.Exported_for_scheduler.with_options" class="ocaml_internal">with_options</a></code></pre>
<pre class="odoccode"><span class="VALschedule"><span class="keyword">val</span> schedule</span> : <code class="type">((unit -&gt; unit) -&gt; unit) <a href="http://127.0.0.1:8000/async_kernel/#Monitor.Exported_for_scheduler.with_options" class="ocaml_internal">with_options</a></code></pre>
<pre class="odoccode"><span class="VALwithin_context"><span class="keyword">val</span> within_context</span> : <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Execution_context.t">Execution_context.t</a> -&gt; (unit -&gt; 'a) -&gt; ('a, unit) <a href="http://127.0.0.1:8000/core/#Std.Result.t">Core.Std.Result.t</a></code></pre>
<pre class="odoccode"><span class="VALpreserve_execution_context"><span class="keyword">val</span> preserve_execution_context</span> : <code class="type">('a -&gt; unit) -&gt; ('a -&gt; unit) <a href="http://127.0.0.1:8000/core/#Std.Staged.t">Core.Std.Staged.t</a></code></pre>
<pre class="odoccode"><span class="VALpreserve_execution_context'"><span class="keyword">val</span> preserve_execution_context'</span> : <code class="type">('a -&gt; 'b <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a>) -&gt; ('a -&gt; 'b <a href="http://127.0.0.1:8000/async_kernel/#Deferred.t">Deferred.t</a>) <a href="http://127.0.0.1:8000/core/#Std.Staged.t">Core.Std.Staged.t</a></code></pre></div></div>
<pre class="odoccode"><span class="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type"><a href="http://127.0.0.1:8000/async_kernel/#Monitor.t" class="ocaml_internal">t</a> -&gt; <a href="http://127.0.0.1:8000/sexplib/#Sexp.t">Sexplib.Sexp.t</a></code></pre>
</div></div>